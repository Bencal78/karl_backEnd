import pandas as pdimport reimport jsonimport numpy as npfrom itertools import productdef create_tastes_from_file(df_csv):    """    :param df_csv: contains the results of the google form test    :return: a dataframe containing the results of the from idUser | id_0 | id_1 | decision (True/False)    """    """PREMIERE PARTIE : création du dataframe contenant toutes les réponses à toutes les questions"""    # récupération des colonnes pertinentes pour la création de la table    relevant_columns = df_csv.iloc[:, 3:]    df_relevant = pd.DataFrame()    # division des vetements avec les virgules    for idrow, row in relevant_columns.iterrows():        row = row.apply(lambda x: re.split('\, ', str(x)))        df_relevant = df_relevant.append(row, ignore_index=True)    # récupération de la dernière ligne du test où on a répondu à toutes les question, transformation en dictionnaire    dict_all = df_relevant.iloc[-1].to_dict()    list_all = list()    for key, value in dict_all.items():        key = [key]        list_all = list_all + (list(product(key, value)))    # création du dataframe avex toutes les réponses à toutes les questions    df_complete = pd.DataFrame(list_all, columns=["id_0", "id_1"])    df_complete["decision"] = False    """DEUXIEME PARTIE : Traduction du fichier du google form"""    # initialisation du dataframe de sortie contenant tous les goûts    df_tastes_true = pd.DataFrame(columns=["idUser", "id_0", "id_1", "decision"])    # création du dataframe avec uniquement les goûts positifs    for idrow, row in df_csv.iterrows():        row = row.dropna().apply(lambda x: re.split('\, ', str(x)))        for colname, col in row[3:].iteritems():            for cloth in col:                df_tastes_true = df_tastes_true.append(                    pd.Series({"idUser": int(idrow), "id_0": colname, "id_1": cloth, "decision": True}),                    ignore_index=True)    """TROISIEME PARTIE : Ajout des goûts à false dans le dataframe."""    df_merge_final = pd.DataFrame(columns=["idUser", "id_0", "id_1", "decision"])    for id in range(max(df_tastes_true["idUser"])):        df_merge_temp = pd.merge(df_tastes_true.loc[df_tastes_true["idUser"] == id + 1], df_complete, how="right",                                 on=['id_0', 'id_1'])        df_merge_temp["decision_x"] = df_merge_temp["decision_x"].fillna(False)        df_merge_temp["idUser"] = df_merge_temp["idUser"].fillna(id + 1)        df_merge_temp = df_merge_temp.iloc[:, 0:4]        df_merge_temp = df_merge_temp.rename(index=str, columns={"decision_x": "decision"})        df_merge_final = df_merge_final.append(df_merge_temp, ignore_index=True)        # enregitrement dans un csv    df_merge_final.to_csv("../database/formulaire_result_names.csv", sep=",")    return df_merge_finaldef create_df_clothes(clothes_df):    """    Convert a dict of clothes to a dataframe, also dummify bodypart's features    :param clothes: a dictionnary of clothes    :return:    credits : benoit leguay    """    bodypart_df = pd.get_dummies(clothes_df.bodyparts.apply(pd.Series).stack()).sum(level=0).rename(        columns=lambda x: "bp_{}".format(int(x)))    clothes_df = pd.concat([clothes_df.drop(columns=['bodyparts']), bodypart_df], axis=1)    return clothes_dfdef get_test_clothes():    """    returns clothes to run tests    :return:    """    file = '../database/clothes.json'    with open(file) as train_file:        dict_clothes = json.load(train_file)    df_clothes = pd.DataFrame(dict_clothes["clothes"])    df_clothes = create_df_clothes(df_clothes)    df_clothes.reset_index(inplace=True, drop=True)    return df_clothesdef filter_clothes_for_user(clothes, dict_bayes):    """    returns clothes that are in the tastes of the user to avoid errors    :param clothes:    :param dict_bayes:    :return:    """    clothes = clothes[clothes["_id"].isin(dict_bayes["clothes_ids"]["scores"].columns)]    clothes.reset_index(inplace=True, drop=True)    return clothesdef add_col_row_to_bayes_dict(dict_bayes, feature):    """    Ajoute une ligne et une colonne pour la feature si besoin    :param dict_bayes: dictionnaire où sont les scores et les comptes pour les features    :param feature: feature à ajouter si besoin    :return: dictionnaire avec une colonne et ligne ajoutées pour la feature d'entrée si besoin    """    if feature not in dict_bayes['scores'].columns:        #création des lignes et colonnes dans le dataframe des scores si besoin        dict_bayes['scores'][feature] = pd.Series()        new_row = pd.Series()        new_row.name = feature        dict_bayes['scores'] = dict_bayes['scores'].append(new_row)        # création des lignes et colonnes dans le dataframe des comptes si besoin        dict_bayes['counts'][feature] = pd.Series()        new_row = pd.Series()        new_row.name = feature        dict_bayes['counts'] = dict_bayes['counts'].append(new_row)    return dict_bayesdef add_to_single_dict(dict_bayes, feature_1, feature_2, decision):    """    Remplit le dictionnaire des goûts à l'aides de deux features/ids et une variable indiquant si    l'utilisateur a aimé cette association de features/ids ou non.    D'une part, le dictionnaire "counts" est incrémenté pour les valeurs des features d'entrée.    D'autre part, le dictionnaire "scores" est augmenté pour les valeurs des features d'entrée d'après la formule:    (score + {(n'a pas aimé) : 0; (a aimé) : 1}) / (compte + 1)    :param dict_bayes:    :param feature_1: valeur de la feature pour le premier vêtement    :param feature_2: valeur de la feature pour le deuxième vêtement    :param decision: booléen désignant si l'utilisateur a aimé ou non l'association de ces vêtements    :return: le dictionnaire rempli en fonction des valeurs d'entrée    """    # on ajoute les valeurs des features aux colonnes si ce n'est pas deja fait    dict_bayes = add_col_row_to_bayes_dict(dict_bayes, feature_1)    dict_bayes = add_col_row_to_bayes_dict(dict_bayes, feature_2)    # on remplit les cases vides avec des 0, au cas où des colonnes ont été ajoutées    dict_bayes["scores"] = dict_bayes["scores"].fillna(0)    dict_bayes["counts"] = dict_bayes["counts"].fillna(0)    # valeur de la variable de score dépend de la décision    score = 1 if decision else 0    # la table "counts" est incrémentée, et le "score" est augmenté ou abaissé en fonction de si l'utilisateur a aimé    # ou non l'association des features    dict_bayes["counts"][feature_1][feature_2] += 1    dict_bayes["scores"][feature_1][feature_2] = (dict_bayes["scores"][feature_1][feature_2] * (dict_bayes["counts"][feature_1][feature_2] - 1) + score) / dict_bayes["counts"][feature_1][feature_2]    dict_bayes["counts"][feature_2][feature_1] += 1    dict_bayes["scores"][feature_2][feature_1] = (dict_bayes["scores"][feature_2][feature_1] * (dict_bayes["counts"][feature_2][feature_1] - 1) + score) / dict_bayes["counts"][feature_2][feature_1]    return dict_bayesdef add_to_all_dicts(dict_bayes, clothes_1, clothes_2, decision):    """    Remplit le dictionnaire des goûts à l'aides des informations de deux vêtements et une variable indiquant si    l'utilisateur a aimé cette association ou non    :param dict_bayes: dictionnaire contenant les données de l'utilisateur relatives à l'algo Naive Bayes    :param clothes_1: dataframe contenant les informations du premier vêtement    :param clothes_2: dataframe contenant les informations du deuxieme vêtement    :param decision: booléen désignant si l'utilisateur a aimé ou non l'association de ces vêtements    :return: dictionnaire rempli à l'aide des paramètres d'entrée    """    features_names = ["colors", "fabrics", "category", "pattern"]  # liste contenant les features qui nous intéressent    for feature in features_names:  # pour toutes les features        if not(clothes_1[feature].empty | clothes_2[feature].empty):  # si les deux vêtements ont cette feature            if type(clothes_1[feature].iloc[0]) == list:  # si la feature a plusieurs valeurs                for feature_1_n in range(len(clothes_1[feature].iloc[0])): # pour toutes les valeurs des features des ..                    for feature_2_n in range(len(clothes_2[feature].iloc[0])):  # .. 2 vetements                        #on nourrit le dictionnaire avec ces features                        dict_bayes[feature] = add_to_single_dict(dict_bayes[feature], clothes_1[feature].iloc[0][feature_1_n], clothes_2[feature].iloc[0][feature_2_n], decision)            else:  # si la feature a une seule valeur                # on nourrit le dictionnaire avec cette feature                dict_bayes[feature] = add_to_single_dict(dict_bayes[feature], clothes_1[feature].iloc[0],                                                         clothes_2[feature].iloc[0], decision)    # On nourrit le dictionnaire des ids de vêtements aussi    if not (clothes_1["_id"].empty | clothes_2["_id"].empty):        dict_bayes["clothes_ids"] = add_to_single_dict(dict_bayes["clothes_ids"], clothes_1["_id"].iloc[0],            clothes_2["_id"].iloc[0], decision)    return dict_bayesdef init_bayes_dictionary():    """    création du dictionnaire pour un utilisateur    :return: le dictionnaire en question    """    # création des dictionnaires contenant les informations pour la naive bayes, pour les couleurs, matières,    # catégories, motifs, et vêtements en entier    dict_clothes_bayes = {"scores": pd.DataFrame(), "counts": pd.DataFrame()}    dict_colors = {"scores": pd.DataFrame(), "counts": pd.DataFrame()}    dict_fabrics = {"scores": pd.DataFrame(), "counts": pd.DataFrame()}    dict_categories = {"scores": pd.DataFrame(), "counts": pd.DataFrame()}    dict_pattern = {"scores": pd.DataFrame(), "counts": pd.DataFrame()}    # On met tous les dictionnaires dans un seul    dict_bayes = {"clothes_ids": dict_clothes_bayes, "colors": dict_colors, "fabrics": dict_fabrics,                  "category": dict_categories, "pattern": dict_pattern}    return dict_bayesdef create_bayes_tables_from_form(df_tastes, df_clothes):    """    Creates a dictionary containing the information for Naive BAyes algorithms from users tastes and clothes    :param df_tastes: containing the tastes of the user in the shape of : id_user | id_cloth_1 | id_clothes_2 | decision (bool)    :param df_clothes: a dataframe containing the clothes of the user with all their information    :return: a dictionnary containing all the tastes of the user    """    all_users_bayes = list()  # initialisation de la liste de sortie    for iterId in range(max(df_tastes["idUser"])):  # pour tous les utilisateurs dans df_tastes        dict_bayes = init_bayes_dictionary()  # initialisation du dictionnaire d'utilisateur        # sélection des goûts uniquement pour l'utilisateur actuel        df_user = df_tastes.loc[df_tastes["idUser"] == iterId + 1]        df_user = df_user.dropna()        #pour tous les goûts de l'utilisateur, on les enregistre dans le dictionnaire.        for id_taste, taste in df_user.iterrows():            clothes_0 = df_clothes[df_clothes['_id'] == taste["id_0"]]            clothes_1 = df_clothes[df_clothes['_id'] == taste["id_1"]]            dict_bayes = add_to_all_dicts(dict_bayes, clothes_0, clothes_1, taste["decision"])        #ajout des goûts de l'utilisateur dans le dictionnaire        all_users_bayes.append(dict_bayes)    return all_users_bayesdef save_nb_data(dict_bayes):    """    Saves the naive bayes data in json files    :param dict_bayes:    :return:    """    for key_feature_category, value_feature_category in dict_bayes.items():        for key_data, value_data in value_feature_category.items():            filename = '../database/' + key_feature_category + '_' + key_data + '.json'            value_data_json = pd.DataFrame.to_json(value_data)            with open(filename, 'w') as outfile:                json.dump(value_data_json, outfile)def load_nb_data():    """    Load the naive bayes data for one user from json files    :return:    """    dict_bayes = init_bayes_dictionary()    for key_feature_category, value_feature_category in dict_bayes.items():        for key_data, value_data in value_feature_category.items():            filename = '../database/' + key_feature_category + '_' + key_data + '.json'            dict_data = json.loads(json.load(open(filename)))            dict_bayes[key_feature_category][key_data] = pd.DataFrame.from_dict(dict_data)    return dict_bayesdef select_clothes(clothes, category):    if category == "top_1":        bp = "bp_1"        layer = 1    if category == "top_2":        bp = "bp_1"        layer = 2    if category == "top_3":        bp = "bp_1"        layer = 3    if category == "bottom":        bp = "bp_5"        layer = 1    clothes_filtered = clothes.loc[(clothes[bp] == 1) & (clothes["layer"] == layer)]    return clothes_filtereddef select_garment_nb_curious(dict_bayes, df_clothes, first_garment = False, outfit = []):    features_names = ["colors", "fabrics", "category", "pattern"]    if first_garment:        id_clothes_counts_filtered = dict_bayes["clothes_ids"]["counts"].loc[df_clothes["_id"], df_clothes["_id"]]        summed_id_clothes_counts = id_clothes_counts_filtered.sum()        id_clothes_less_used = summed_id_clothes_counts[summed_id_clothes_counts == min(summed_id_clothes_counts)].index        garment_id = id_clothes_less_used[np.random.randint(id_clothes_less_used.shape[0])]        garment = df_clothes[df_clothes["_id"] == garment_id]    else:        #id_clothes_count = np.zeros(())        id_clothes_counts_filtered = dict_bayes["clothes_ids"]["counts"].loc[df_clothes["_id"]]        # number of occurences of associations between the clothes from the outfit and the candidate clothes        id_clothes_counts = pd.DataFrame(0, index=id_clothes_counts_filtered.index, columns=["init"])        # scores for each candidate clothes        id_clothes_scores = pd.DataFrame(0, index=id_clothes_counts_filtered.index, columns=["scores","n_scores"])        print(id_clothes_scores)        keys=["colors", "category", "fabrics", "pattern"]        for garment in outfit:            #print(garment)            id_garment_counts = id_clothes_counts_filtered.loc[:, garment["_id"]]            id_clothes_counts = pd.concat([id_clothes_counts, id_garment_counts], axis=1, join_axes=[id_clothes_counts.index])            id_clothes_counts = id_clothes_counts.sum(axis=1)            #print(id_clothes_counts)            #print(type(garment))            for key, value in dict_bayes.items():                #print(key)                #print(value)                if key in features_names:                    if not garment[key].empty:  # si les deux vêtements ont cette feature                        if type(garment[key].iloc[0]) == list:  # si la feature a plusieurs valeurs                            #print(garment[key].iloc[0])                            for feature in garment[key].iloc[0]:  # pour toutes les valeurs des features des ..                                #print(value["scores"][feature])                                for id_clothes_candidate_scores in id_clothes_scores.index:                                    if type(df_clothes[df_clothes["_id"] == id_clothes_candidate_scores][key].iloc[0]) == list:                                        for feature_2 in df_clothes[df_clothes["_id"] == id_clothes_candidate_scores][key].iloc[0]:                                            id_clothes_scores.loc[id_clothes_candidate_scores, "scores"] = \                                                id_clothes_scores.loc[id_clothes_candidate_scores, "scores"] + value["scores"].loc[feature_2, feature]                                            id_clothes_scores.loc[id_clothes_candidate_scores, "n_scores"] += 1                                    else:                                        id_clothes_scores.loc[id_clothes_candidate_scores, "scores"] = \                                        id_clothes_scores.loc[id_clothes_candidate_scores, "scores"] + value["scores"].loc[df_clothes[df_clothes["_id"] == id_clothes_candidate_scores][key], feature].iloc[0].iloc[0]                                        id_clothes_scores.loc[id_clothes_candidate_scores, "n_scores"] += 1                        else:                            for id_clothes_candidate_scores in id_clothes_scores.index:                                id_clothes_scores.loc[id_clothes_candidate_scores,"scores"] = id_clothes_scores.loc[id_clothes_candidate_scores, "scores"] + value["scores"].loc[df_clothes[df_clothes["_id"] == id_clothes_candidate_scores][key],garment[key]].iloc[0].iloc[0]                                id_clothes_scores.loc[id_clothes_candidate_scores, "n_scores"] +=1            id_clothes_scores["scores"] = id_clothes_scores["scores"] / id_clothes_scores["n_scores"]            print(id_clothes_scores)                    #if key != "clothes_ids":                    #print(value)                    #garment = None        #id_clothes_counts_scores = id_clothes_counts / id_clothes_counts.max()    return garmentdef create_outfit_nb_curious(dict_bayes, df_clothes):    outfit = []    first_garment_random_index = np.random.randint(2)    if first_garment_random_index == 0:        # premiere fringue est haut        clothes_selected = select_clothes(df_clothes, "top_1")    else:        # premiere fringue en bas        clothes_selected = select_clothes(df_clothes, "bottom")    first_garment = select_garment_nb_curious(dict_bayes, clothes_selected, first_garment=True)    outfit.append(first_garment)    if first_garment_random_index == 0:        clothes_selected = select_clothes(df_clothes, "bottom")    else:        clothes_selected = select_clothes(df_clothes, "top_1")    second_garment = select_garment_nb_curious(dict_bayes, clothes_selected, outfit=outfit)    return outfitdef create_outfit_nb_safe():    passdef create_outfit_nb(dict_bayes, df_clothes, choice_mode="curious"):    """    Selects an outfit creation algorithm and returns an outfit made by one of these    :param user:    :param choice_mode:    :return:    """    outfit = list()    if choice_mode == "curious":        outfit = create_outfit_nb_curious(dict_bayes, df_clothes)    elif choice_mode == "safe":        outfit = create_outfit_nb_safe(dict_bayes, df_clothes)    return outfitif __name__ == "__main__":    '''    df_form = pd.read_excel("../database/formulaire_test_id.xlsx")    #print(df_form)    df_tastes = create_tastes_from_file(df_form)    '''    '''    df_tastes = pd.read_csv("../database/formulaire_result_ids.csv", index_col = 0)        df_clothes = get_test_clothes()    #print(df_clothes)    dict_bayes = create_bayes_tables_from_form(df_tastes, df_clothes)    save_nb_data(dict_bayes[0])    '''    dict_bayes = load_nb_data()    df_clothes = get_test_clothes()    df_clothes = filter_clothes_for_user(df_clothes, dict_bayes)    outfit = create_outfit_nb(dict_bayes, df_clothes)    id_clothes_counts = dict_bayes["clothes_ids"]["counts"].sum()    id_clothes_counts_scores = 1 - id_clothes_counts / id_clothes_counts.max()    id_clothes_less_used = id_clothes_counts[id_clothes_counts == min(id_clothes_counts)].index    #lol = id_clothes_less_used[np.random.randint(id_clothes_less_used.shape[0])]    #print(id_clothes_counts_scores)    #print(df_clothes)    #print(dict_bayes)